<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My blog.]]></title>
  <link href="http://RajivKurian.github.io/atom.xml" rel="self"/>
  <link href="http://RajivKurian.github.io/"/>
  <updated>2014-11-12T09:23:35-08:00</updated>
  <id>http://RajivKurian.github.io/</id>
  <author>
    <name><![CDATA[Rajiv]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hashed Wheel Timer - an Exercise in Data Structures]]></title>
    <link href="http://RajivKurian.github.io/blog/2014/11/11/hashed-wheel-timer-an-exercise-in-data-structures/"/>
    <updated>2014-11-11T20:22:55-08:00</updated>
    <id>http://RajivKurian.github.io/blog/2014/11/11/hashed-wheel-timer-an-exercise-in-data-structures</id>
    <content type="html"><![CDATA[<h2>Hashed wheel timers &ndash; A short intro.</h2>

<p>The Hashed wheel timer is a very interesting data structure used widely especially in network servers. Their low over memory over head and reasonable efficiency guarantees are a good match for servers handling millions of connections with a timer per connection. We will not spend too much time describing how they work, instead we will look at a few implementations and try to evaulate their relative trade-offs. More information about hashed-wheel-timers can be found <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf">here</a>.</p>

<!-- more -->


<p>Let&rsquo;s quickly recollect the basic data structures of a hashed wheel timer:</p>

<p align="center">
<img src="http://RajivKurian.github.io/images/hashed-wheel-timer-basic.svg" width="500">
</p>


<p>The basic data structure looks like a hashmap with separate chaining with lists. Each bucket represents a fixed number of ticks. When a timer is added to the wheel we calculate which bucket it should fall into. Though any hashing scheme would do, we usually just travel forward from the current time pointer one bucket at a time, till we have consumed enough ticks for our timeout to have just triggered. We then insert the timer into the list for that bucket. Given that we have a finite number of buckets, we might have to circle around the timer wheel a few times before we can insert our timer. We will need to store this information with the timer. This is typically stored as a <code>remainingRounds</code> variable.</p>

<p>The first draft of an interface for out fictional timer is:</p>

<figure class='code'><figcaption><span>TimerWheel.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">TimerWheel</span> <span class="p">{</span>
</span><span class='line'><span class="k">public</span><span class="o">:</span>
</span><span class='line'>  <span class="c1">// Fields ....</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// A Timer is uniquely identified by an id.</span>
</span><span class='line'>  <span class="c1">// We don&#39;t care how this id is generated.</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">add_timer</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">delay</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">id</span><span class="p">);</span>  <span class="c1">// Assume that the delay is in nanos for now.</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">cancel_timer</span><span class="p">(</span><span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// Write the list of expired ids into the input array, assuming it is long enough.</span>
</span><span class='line'>  <span class="c1">// Returning a list of expired timers instead of calling the expiry processing inline</span>
</span><span class='line'>  <span class="c1">// helps in ensuring the integrity of internal timer data structures</span>
</span><span class='line'>  <span class="c1">// since all we need to do is ensure that the timer structures are</span>
</span><span class='line'>  <span class="c1">// consistent before and after a function call, but not during.</span>
</span><span class='line'>  <span class="kt">void</span> <span class="n">expire_timers</span><span class="p">(</span><span class="n">uint64_t</span><span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Usually a timer is implemented with a more generic interface with some kind of a <code>Runnable</code> task per timer that is executed upon timer expiry. We have made things a lot more specific and require that each timer has an unique id. We also leave the execution of code corresponding to each expired timer up to the user of the library. We could use some other identifier instead of an id. For eg: A pointer to a per connection structure if the timers are for closing stale connections.</p>

<p>So the absolute minimum data we need to have in our timers is:</p>

<figure class='code'><figcaption><span>Timer.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">id</span><span class="p">;</span>  <span class="c1">// Or some other unique identifier. 8 bytes should be enough.</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">deadline</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">remaining_rounds</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// Other stuff...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Given this basic scheme let&rsquo;s look at some of the ways we could implement the interface we showed earlier</p>

<h5>1. Linked list of timers per bucket.</h5>

<p align="center">
<img src="http://RajivKurian.github.io/images/hashed-wheel-timer-linked-list.svg" width="500">
</p>


<p>Each bucket simply points to an intrusive doubly linked list of timers. Our data structures look like:</p>

<figure class='code'><figcaption><span>Timer.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">enum</span> <span class="n">PreviousType</span> <span class="p">{</span><span class="n">Timer</span><span class="p">,</span> <span class="n">TimerWheel</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">id</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">deadline</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">remaining_rounds</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// A tagged union since the previous could be either a</span>
</span><span class='line'>  <span class="c1">// pointer to a timer or a pointer to the bucket.</span>
</span><span class='line'>  <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Timer</span><span class="o">*</span> <span class="n">previous</span><span class="p">;</span>
</span><span class='line'>    <span class="n">TimerBucket</span><span class="o">*</span> <span class="n">wheel</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">PreviousType</span> <span class="n">previousType</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">TimerBucket</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">timer_list</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">TimerWheel</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">TimerBucket</span><span class="p">[</span><span class="n">NUM_BUCKETS</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">// Other stuff.</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Methods...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Our algorithms look like</p>

<figure class='code'><figcaption><span>TimerWheel.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Timer</span><span class="o">*</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">add_timer</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">delay</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">create_timer</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span><span class='line'>  <span class="n">TimerBucket</span><span class="o">*</span> <span class="n">bucket</span> <span class="o">=</span> <span class="n">findBucket</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// Just prepend the timer to the linked list at the bucket;</span>
</span><span class='line'>  <span class="n">insert_into_bucket</span><span class="p">(</span><span class="n">bucket_id</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">timer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">cancel_timer</span><span class="p">(</span><span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Since the timer is part of a doubly linked list,</span>
</span><span class='line'>  <span class="c1">// just delete it from the linked list and free the memory.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Write the list of expired ids into the input array, assuming it is long enough.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">expire_timers</span><span class="p">(</span><span class="n">uint64_t</span><span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// If it wasn&#39;t already clear this is pseudo code.</span>
</span><span class='line'>  <span class="n">deadline</span> <span class="o">=</span> <span class="n">calculate_deadline</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">num_ids_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">bucket</span> <span class="o">:</span> <span class="n">every</span> <span class="n">bucket</span> <span class="n">that</span> <span class="n">could</span> <span class="n">contain</span> <span class="n">expired</span> <span class="n">timers</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">timer</span> <span class="o">:</span> <span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">remainingRounds</span> <span class="o">&amp;&amp;</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">deadline</span> <span class="o">&lt;=</span> <span class="n">deadline</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">append_to_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_ids_added</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cancel_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">--</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">remainingRounds</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So our algorithm characteristics in brief are:</p>

<ol>
<li>To add a timer, just prepend it to the appropriate linked list &ndash; <code>O(1)</code></li>
<li>To cancel a timer &ndash; delete it from the doubly linked list &ndash; <code>O(1)</code></li>
<li>To clean up all expired timers &ndash; Travel list of timers and delete expired ones &ndash; <code>O(expired timers)</code>. The actual time depends on how many timers hashed onto a bucket. We can put some bounds on this number with general hash table math.</li>
</ol>


<h6>Comments on implementation.</h6>

<p>This is our base line. We have significant memory over head in terms of previous/next pointers on our timers. It&rsquo;s pretty terrible that we have to <code>malloc()</code> and <code>free()</code> on each <code>add_timer()</code> and <code>cancel_timer()</code> call. Of course the <code>O(1)</code> calls also hide the fact that we are traversing a linked list during timer expiry which is pretty terrible.</p>

<h5>2. Vector of timer pointers per bucket.</h5>

<p align="center">
<img src="http://RajivKurian.github.io/images/hashed-wheel-timer-vector.svg" width="500">
</p>


<p>Instead of an intrusive linked list we can just store a vector of pointers to timers. We can grow this vector as needed. If memory is not a concern we could allocate a large enough array so that growing is never needed (though still accounted for). Our timer struct now looks like:</p>

<figure class='code'><figcaption><span>Timer.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">id</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">deadline</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">remaining_rounds</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">TimerBucket</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// Array of pointers to timers.</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">timers</span><span class="p">[];</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">TimerWheel</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">TimerBucket</span><span class="p">[</span><span class="n">NUM_BUCKETS</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">// Other stuff.</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Methods...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Our algorithms look like</p>

<figure class='code'><figcaption><span>TimerWheel.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Timer</span><span class="o">*</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">add_timer</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">delay</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">id</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">create_timer</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
</span><span class='line'>  <span class="n">TimerBucket</span><span class="o">*</span> <span class="n">bucket</span> <span class="o">=</span> <span class="n">findBucket</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// Just append the timer to the vector for the bucket.</span>
</span><span class='line'>  <span class="n">append_to_bucket</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">timer</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">timer</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">cancel_timer</span><span class="p">(</span><span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Since the timer is part of a vector, we can&#39;t just adjust a couple pointers.</span>
</span><span class='line'>  <span class="c1">// Since ordering within the vector is not important, we copy the last</span>
</span><span class='line'>  <span class="c1">// timer pointer (if the deleted timer wasn&#39;t the last one in the vector)</span>
</span><span class='line'>  <span class="c1">// to the deleted position.</span>
</span><span class='line'>  <span class="c1">// Decrement the vector size by 1.</span>
</span><span class='line'>  <span class="c1">// Moving the pointer to a timer within the vector doesn&#39;t invalidate the</span>
</span><span class='line'>  <span class="c1">// pointer, so it&#39;s perfectly safe.</span>
</span><span class='line'>  <span class="c1">// We then free the memory used by the timer.</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// The expiry logic remains similar. We just traverse an array of pointers now</span>
</span><span class='line'><span class="c1">// instead of a doubly linked list.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">expire_timers</span><span class="p">(</span><span class="n">uint64_t</span><span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// If it wasn&#39;t already clear this is pseudo code.</span>
</span><span class='line'>  <span class="n">deadline</span> <span class="o">=</span> <span class="n">calculate_deadline</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">num_ids_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">bucket</span> <span class="o">:</span> <span class="n">every</span> <span class="n">bucket</span> <span class="n">that</span> <span class="n">could</span> <span class="n">contain</span> <span class="n">expired</span> <span class="n">timers</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">timer</span> <span class="o">:</span> <span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">remainingRounds</span> <span class="o">&amp;&amp;</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">deadline</span> <span class="o">&lt;=</span> <span class="n">deadline</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">append_to_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_ids_added</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cancel_timer</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">--</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">remainingRounds</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So our algorithm characteristics in brief are:</p>

<ol>
<li>To add a timer, just append it to the appropriate vector &ndash; <code>O(1)</code>.</li>
<li>To cancel a timer, delete it from the middle of the vector and move a pointer to occupy the hole  &ndash; <code>O(1)</code>.</li>
<li>To clean up all expired timers &ndash; Traverse the vector of timers and delete expired ones &ndash; <code>O(expired timers)</code>. Again actual time depends on how many timers hashed onto a bucket.</li>
</ol>


<h6>Comments on implementation.</h6>

<p>This is a slight improvement on our base line. By using a vector of pointers to timers we have removed the need for the next pointers &ndash; a slight improvement in space usage. We still have the terrible pattern of having to  use <code>malloc()</code> and <code>free()</code> on each <code>add_timer()</code> and <code>cancel_timer()</code> call. During expiry of timers we now traverse a vector of pointers to timers instead of a linked list. This is only marginally better than the first implementation since the timers themselves are allocated randomly.</p>

<h5>3. Vector of inlined timers.</h5>

<p align="center">
<img src="http://RajivKurian.github.io/images/hashed-wheel-timer-inlined-vector.svg" width="500">
</p>


<p>Let&rsquo;s see if we can improve effiency by making our interface even more specialized. So far we have returned a <code>Timer*</code> on an <code>add_timer()</code> call. Our intented use for the <code>Timer*</code> is to cancel the timer using this pointer. Thus we will end up stashing this pointer somewhere. Maybe on a per connection structure or a hash map or something. What if we could store a pointer to this timer holder structure (that points to our timer) in our timer? We could then safely move/invalidate the pointer to a timer, updating the only place where this timer was actually referenced. Here we assume that the pointer to the timer was stashed in only one place. This is somewhat like our own little garbage collector updating references to timer objects that were moved around. Let&rsquo;s look at our new data structures:</p>

<figure class='code'><figcaption><span>NewTimer.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Holder of a pseudo-pointer to a timer.</span>
</span><span class='line'><span class="c1">// This can be used to cancel the timer.</span>
</span><span class='line'><span class="k">struct</span> <span class="n">TimerHolder</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint32_t</span> <span class="n">bucket_number</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint32_t</span> <span class="n">index_within_bucket</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">id</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">deadline</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">remaining_rounds</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// Pointer to the sole container of this timer.</span>
</span><span class='line'>  <span class="n">TimerHolder</span><span class="o">*</span> <span class="n">holder</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">TimerBucket</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// Array of Timers.</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">timers</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">TimerWheel</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">TimerBucket</span><span class="p">[</span><span class="n">NUM_BUCKETS</span><span class="p">];</span>
</span><span class='line'>  <span class="c1">// Other stuff.</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Methods...</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Our modified interface now is:</p>

<figure class='code'><figcaption><span>TimerWheel.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// Put the pointer to the timer in the holder.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">add_timer</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">delay</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">TimerHolder</span><span class="o">*</span> <span class="n">holder</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// The TimerHolder is always kept up to date. Since this is a single threaded timer</span>
</span><span class='line'><span class="c1">// this is not impossible to ensure.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">cancel_timer</span><span class="p">(</span><span class="n">TimerHolder</span><span class="o">*</span> <span class="n">timer</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Write the list of expired ids into the input array, assuming it is long enough.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">expire_timers</span><span class="p">(</span><span class="n">uint64_t</span><span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">size</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>Our algorithms look like</p>

<figure class='code'><figcaption><span>TimerWheel.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="kt">void</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">add_timer</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">delay</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">id</span><span class="p">,</span> <span class="n">TimerHolder</span><span class="o">*</span> <span class="n">holder</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">TimerBucket</span><span class="o">*</span> <span class="n">bucket</span> <span class="o">=</span> <span class="n">findBucket</span><span class="p">(</span><span class="n">timer</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// Just append timer to end of the bucket, no malloc needed.</span>
</span><span class='line'>  <span class="c1">// Update the holder to contain the bucket_number and index_within_bucket.</span>
</span><span class='line'>  <span class="n">initalize_timer</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">holder</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">cancel_timer</span><span class="p">(</span><span class="n">TimerHolder</span><span class="o">*</span> <span class="n">holder</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Do some sanity checking first.</span>
</span><span class='line'>  <span class="n">TimerBucket</span><span class="o">*</span> <span class="n">bucket</span> <span class="o">=</span> <span class="n">find_bucket</span><span class="p">(</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">bucket_number</span><span class="p">);</span>
</span><span class='line'>  <span class="n">uint32_t</span> <span class="n">cancelled_timer_index</span> <span class="o">=</span> <span class="n">holder</span><span class="o">-&gt;</span><span class="n">index_within_bucket</span><span class="p">;</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span> <span class="o">=</span> <span class="n">find_timer</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">cancelled_timer_index</span><span class="p">);</span>
</span><span class='line'>  <span class="c1">// We need to cancel this timer.</span>
</span><span class='line'>  <span class="c1">// Just memcpy the last timer in this bucket to occupy the deleted place.</span>
</span><span class='line'>  <span class="c1">// A timer is just 32 bytes, copying it VS copying a pointer is not a big deal.</span>
</span><span class='line'>  <span class="c1">// If the cancelled timer is the last timer in this bucket no copy is needed.</span>
</span><span class='line'>  <span class="c1">// Decrement the vector size by 1.</span>
</span><span class='line'>  <span class="n">Timer</span><span class="o">*</span> <span class="n">moved_timer</span> <span class="o">=</span> <span class="n">move_last_timer_if_needed</span><span class="p">(</span><span class="n">bucket</span><span class="p">,</span> <span class="n">cancelled_timer_index</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">moved_timer</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// If a timer that was moved, change it&#39;s holder&#39;s offsets, </span>
</span><span class='line'>    <span class="c1">// so it points to the new location of the timer.</span>
</span><span class='line'>    <span class="n">adjust_holder_pointer</span><span class="p">(</span><span class="n">moved_timer</span><span class="o">-&gt;</span><span class="n">holder</span><span class="p">,</span> <span class="n">cancelled_timer_index</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="c1">// The holder for the deleted timer should now contain a null ptr.</span>
</span><span class='line'>  <span class="c1">// The caller will decide what to do with the holder after this function returns.</span>
</span><span class='line'>  <span class="n">invalidate_holder_timer</span><span class="p">(</span><span class="n">holder</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// The expiry logic remains similar. We just traverse an array of inlined timers now.</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="n">TimerWheel</span><span class="o">::</span><span class="n">expire_timers</span><span class="p">(</span><span class="n">uint64_t</span><span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// If it wasn&#39;t already clear this is pseudo code.</span>
</span><span class='line'>  <span class="n">deadline</span> <span class="o">=</span> <span class="n">calculate_deadline</span><span class="p">();</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">num_ids_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="n">bucket</span> <span class="o">:</span> <span class="n">every</span> <span class="n">bucket</span> <span class="n">that</span> <span class="n">could</span> <span class="n">contain</span> <span class="n">expired</span> <span class="n">timers</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">timer</span> <span class="o">:</span> <span class="n">bucket</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&gt;=</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">remainingRounds</span> <span class="o">&amp;&amp;</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">deadline</span> <span class="o">&lt;=</span> <span class="n">deadline</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">append_to_ids</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_ids_added</span><span class="p">,</span> <span class="n">timer</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
</span><span class='line'>        <span class="n">cancel_timer</span><span class="p">(</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">holder</span><span class="p">);</span>
</span><span class='line'>      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="o">--</span><span class="n">timer</span><span class="o">-&gt;</span><span class="n">remainingRounds</span><span class="p">;</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>So our algorithm characteristics in brief are:</p>

<ol>
<li>To add a timer, just scribble some data to the end of the appropriate vector &ndash; <code>O(1)</code>.</li>
<li>To cancel a timer, copy the last timer in the bucket to the position of the deleted one and adjust references to the moved timer &ndash; <code>O(1)</code>.</li>
<li>To clean up all expired timers &ndash; Traverse the vector of timers and delete expired ones using the <code>cancel_timer()</code> call &ndash; <code>O(expired timers)</code>. Again actual time depends on how many timers hashed onto a bucket.</li>
</ol>


<h6>Comments on implementation.</h6>

<p>We no longer call <code>malloc()</code> and <code>free()</code> on every timer call. Instead we manage large buckets and copy small amounts of data around to manage deletions. We ended up storing a pointer to the holder of the timer object but overall we are not storing any more data that the other implementations. When we got rid of the <code>malloc()</code> and <code>free()</code> calls we also got rid of any fragmentation arising from them. Further during expiry processing we iterate through a chunk of contiguous memory instead of pointer chasing.</p>

<h3>Conclusion</h3>

<p>By analyzing the context of our timer algorithm we were able to come up with a better implementation albeit a more tightly coupled one. Wholistic analysis of a particular piece of software often opens up such opportunities for efficiency gains. Though many a time there is a <code>efficiency</code> VS <code>other-non-tangibles</code> trade-off, I&rsquo;ve been surprised by the number of times such gains have been made without tigher coupling.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading Length Prefixed Protocols]]></title>
    <link href="http://RajivKurian.github.io/blog/2014/11/11/reading-length-prefixed-protocols/"/>
    <updated>2014-11-11T19:52:23-08:00</updated>
    <id>http://RajivKurian.github.io/blog/2014/11/11/reading-length-prefixed-protocols</id>
    <content type="html"><![CDATA[<h3>Why length prefixed protocols?</h3>

<p>Protocol design can have a suprisingly large effect on performance. Text-based protocols while good for human readability are far from ideal when it comes to performance. Unless your application almost exclusively deals with strings, a binary protocol could offer significant savings. There is a lot of dogma surrounding binary protocols:</p>

<!-- more -->


<ol>
<li><strong>They are not extensible</strong>: Though it is easy to corner yourself while designing your own binary protocol, this comes from a lack of experience rather than an inherent property. Look at the design of binary interchange formats like Google Protocol Buffers, FIX, Cap&#8217;n Proto etc to see how they address the issues of future extensions.</li>
<li><strong>They are difficult to debug</strong>: This really boils down to the fact that binary protocols are not human readable like XML or JSON are. Building simple tools overcomes these issues. Writing a simple <code>toString()</code> method on the objects that you are transferring is already a big step in being able to debug your protocol.</li>
<li><strong>What about web clients?</strong>: If your service talks to web clients, this is a valid concern. JSON is the de-facto protocol used for server web-client interactions. It&rsquo;s terribly easy to convert Javascript objects to and from JSON. Modern browsers now have support for binary data via <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">typed arrays</a>. These can be used to <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Sending_and_Receiving_Binary_Data">receive and send</a> binary data using the standard XMLHttpRequest interface. You are stuck without a solution on older browsers though so maybe this isn&rsquo;t a great choice at this time.</li>
</ol>


<p>So far we have been talking about binary protocols in general. A length prefixed protocol requires every request be prefixed by its length in bytes. So the first 4/8 bytes of the request tell us the length of the actual payload. The rest of the payload could be text based instead of binary, but that&rsquo;s usually not the norm.</p>

<h4>What can we do with a length prefixed protocol?</h4>

<p>Length prefixed protocols allow us to cheaply check to see if an entire request has been received. All you need to check is to see if you have received all the bytes you were promised. The actual parsing and procesing of the request can be done later, maybe on another thread.</p>

<p>The rest of the article shows some techniques on how to read a length-prefixed request.</p>

<h5>Technique 1.</h5>

<p align="center">
<img src="http://RajivKurian.github.io/images/lpp-2.svg">
</p>


<p>The above approach lets us pick appropriately sized buffers for each request instead of guessing buffer sizes and copying later. It suffers from a problem though. Even for the smallest of requests we need at least <strong>two read calls</strong>. System calls are expensive and should be avoided if possible. Can we do better? We could trade the extra system calls for more complexity, a worse pathological case and larger internal framgentation.</p>

<h5>Technique 2.</h5>

<p align="center">
<img src="http://RajivKurian.github.io/images/lpp-3.svg">
</p>


<p>So if we pick a default buffer size D, such that most of our requests are of <code>size D or less</code>, we minimize the number of read calls. When our requests are of <code>size greater than D</code> we incur some copy. The copy isn&rsquo;t that bad especially if our requests are small. Picking the default buffer size depends on the application. Each option has different shortcomings:</p>

<ol>
<li>Pick too big a size: Internal fragmentation. We have too much unused space.</li>
<li>Pick too small a size: Multiple system calls and copying. This is marginally worse than our previous approach, since it involves the extra copying.</li>
</ol>


<p>Yet another approach is to not copy the contents of the default buffer but to use a <code>list of buffers</code> to hold our request. Since we know the length of our request, we are guaranteed that the list will be of size 1 or 2.</p>

<h5>Technique 3.</h5>

<p align="center">
<img src="http://RajivKurian.github.io/images/lpp-4.svg">
</p>


<p>Here we use scatter reads to read into our default buffer and the overflow buffer using the same system call. We avoid the extra copy but have our request spread over two buffers incurring random read costs when parsing the request.</p>

<p>The right approach depends on what trade-offs make sense for the particular application.</p>

<h4>A work of caution &ndash; Slowloris attacks.</h4>

<p>Though other protocols are vulnerable to <a href="http://en.wikipedia.org/wiki/Slowloris">slowloris attacks</a>, servers that use length prefixed protocols are vulnerable to a particularly nasty attack. Imagine the following attack:</p>

<figure class='code'><figcaption><span>Slowloris attack</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="mf">1.</span> <span class="n">Client</span> <span class="n">connects</span> <span class="n">and</span> <span class="n">says</span> <span class="n">it</span> <span class="n">has</span> <span class="n">a</span> <span class="n">giant</span> <span class="n">request</span><span class="p">,</span> <span class="n">say</span> <span class="n">of</span> <span class="mi">64</span> <span class="n">MB</span><span class="p">.</span>
</span><span class='line'><span class="mf">2.</span> <span class="n">Server</span> <span class="n">allocates</span> <span class="n">a</span> <span class="n">buffer</span> <span class="n">of</span> <span class="n">size</span> <span class="mi">64</span> <span class="n">MB</span> <span class="n">waiting</span> <span class="k">for</span> <span class="n">the</span> <span class="n">bytes</span><span class="p">.</span>
</span><span class='line'><span class="mf">3.</span> <span class="n">Client</span> <span class="n">never</span> <span class="n">sends</span> <span class="n">additional</span> <span class="n">bytes</span> <span class="n">or</span> <span class="n">sends</span> <span class="n">a</span> <span class="n">trickle</span> <span class="n">of</span> <span class="n">bytes</span> <span class="n">infrequently</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p>Not only did the client tie up a connection, it also tied up memory. A flood of these attacks could cause the server to exhaust all buffers. The standard techniques to mitigate slowloris attacks still apply:</p>

<ol>
<li>Timers to disconnect idle clients. Some attackers will send a byte or two every now and then to defeat timers. We could mark a client as <code>potentially evil</code> if it only sends a trickle of bytes one too many times. We could also make our timer more strict for clients we suspect.</li>
<li>Limit the number of connections/requests from the same IP address.</li>
<li>Maintain a blacklist that keeps evolving. Deny connection requests from IP addresses on the blacklist.</li>
</ol>


<p>We can modify our default buffer size technique to make it more resistant to buffer exhaustion:</p>

<ol>
<li>Maintain a default buffer size per client. Start with a low buffer size and as the client gains more trust, increase it up to a limit.</li>
<li>Instead of allocating a buffer of the appropriate size as soon as we know the request length, we could let the client fill up the default buffer before we allocate an overflow buffer. This way we only tie up a smaller buffer till we absolutely need overflow space.</li>
</ol>


<p>The simplest defense though is to use these protocols on trusted networks instead of on the open web.</p>

<h4>Conclusion</h4>

<p>Length prefixed protocols make it really easy to check if a particular request is ready for parsing or not. This is especially a boon for multi-threaded servers where one thread could read bytes off the network and pass a complete request to another thread for parsing and processing. The cheap check implies that the network-thread doesn&rsquo;t have to do much work to decide when to transfer a request to the next stage in the pipeline. The request might still be ill-formed but the parsing/processing thread could take care of it. Let me know in the comments section, if you use other techniques to read length prefixed protocols or if I have missed something.</p>
]]></content>
  </entry>
  
</feed>
