
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Hashed Wheel Timer - an Exercise in Data Structures - My blog.</title>
  <meta name="author" content="Rajiv">

  
  <meta name="description" content="Hashed wheel timers &ndash; A short intro. The Hashed wheel timer is a very interesting data structure used widely especially in network servers. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://RajivKurian.github.io/blog/2014/11/11/hashed-wheel-timer-an-exercise-in-data-structures">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My blog." type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-37425728-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My blog.</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:RajivKurian.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Hashed Wheel Timer - an Exercise in Data Structures</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-11-11T20:22:55-08:00" pubdate data-updated="true">Nov 11<span>th</span>, 2014</time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://RajivKurian.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><h2>Hashed wheel timers &ndash; A short intro.</h2>

<p>The Hashed wheel timer is a very interesting data structure used widely especially in network servers. Their low over memory over head and reasonable efficiency guarantees are a good match for servers handling millions of connections with a timer per connection. We will not spend too much time describing how they work, instead we will look at a few implementations and try to evaulate their relative trade-offs. More information about hashed-wheel-timers can be found <a href="http://www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf">here</a>.</p>

<!-- more -->


<p>Let&rsquo;s quickly recollect the basic data structures of a hashed wheel timer:</p>

<p align="center">
<img src="/images/hashed-wheel-timer-basic.svg" width="500">
</p>


<p>The basic data structure looks like a hashmap with separate chaining with lists. Each bucket represents a fixed number of ticks. When a timer is added to the wheel we calculate which bucket it should fall into. Though any hashing scheme would do, we usually just travel forward from the current time pointer one bucket at a time, till we have consumed enough ticks for our timeout to have just triggered. We then insert the timer into the list for that bucket. Given that we have a finite number of buckets, we might have to circle around the timer wheel a few times before we can insert our timer. We will need to store this information with the timer. This is typically stored as a <code>remainingRounds</code> variable.</p>

<p>The first draft of an interface for out fictional timer is:</p>

<figure class='code'><figcaption><span>TimerWheel.h</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="c1">// A Timer is uniquely identified by an id.</span>
</span><span class='line'><span class="c1">// We don&#39;t care how this id is generated.</span>
</span><span class='line'><span class="n">Timer</span><span class="o">*</span> <span class="n">add_timer</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">delay</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">id</span><span class="p">);</span>  <span class="c1">// Assume that the delay is in nanos for now.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">cancel_timer</span><span class="p">(</span><span class="n">Timer</span><span class="o">*</span> <span class="n">timer</span><span class="p">);</span>
</span><span class='line'><span class="c1">// Write the list of expired ids into the input array, assuming it is long enough.</span>
</span><span class='line'><span class="c1">// Returning a list of expired timers instead of calling the expiry processing inline</span>
</span><span class='line'><span class="c1">// helps in ensuring the integrity of internal timer data structures</span>
</span><span class='line'><span class="c1">// since all we need to do is ensure that the timer structures are</span>
</span><span class='line'><span class="c1">// consistent before and after a function call, but not during.</span>
</span><span class='line'><span class="kt">void</span> <span class="n">expire_timers</span><span class="p">(</span><span class="n">uint64_t</span><span class="o">*</span> <span class="n">ids</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">size</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Usually a timer is implemented with a more generic interface with some kind of a <code>Runnable</code> task per timer that is executed upon timer expiry. We have made things a lot more specific and require that each timer has an unique id. We also leave the execution of code corresponding to each expired timer up to the user of the library. We could use some other identifier instead of an id. For eg: A pointer to a per connection structure if the timers are for closing stale connections.</p>

<p>So the absolute minimum data we need to have in our timers is:</p>

<figure class='code'><figcaption><span>Timer.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="k">struct</span> <span class="n">Timer</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">id</span><span class="p">;</span>  <span class="c1">// Or some other unique identifier. 8 bytes should be enough.</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">deadline</span><span class="p">;</span>
</span><span class='line'>  <span class="n">uint64_t</span> <span class="n">remaining_rounds</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>Given this basic scheme let&rsquo;s look at some of the ways we could implement the interface we showed earlier</p>

<h5>1. Linked list of timers per bucket.</h5>

<p align="center">
<img src="/images/hashed-wheel-timer-linked-list.svg" width="500">
</p>


<p>Each bucket simply points to an intrusive doubly linked list of timers. Our timer struct looks like:</p>

<p>struct Timer {
  uint64_t id;
  uint64_t deadline;
  uint64_t remaining_rounds;
  Timer<em> next;
  // Previous is null if this is the first timer in the list.
  Timer</em> previous;
};</p>

<p>struct TimerBucket {
  Timer* list;
};</p>

<figure class='code'><figcaption><span>Timer.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Our</span> <span class="n">algorithms</span> <span class="n">look</span> <span class="n">like</span>
</span></code></pre></td></tr></table></div></figure>


<p> cpp TimerWheel.cpp
Timer<em> add_timer(uint64_t delay, uint64_t id) {
  Timer</em> timer = create_timer(delay, id);
  TimerBucket* bucket = findBucket(timer);
  // Just prepend the timer to the linked list at the bucket;
  insert_into_bucket(bucket_id, timer);
  return timer;
}</p>

<p>void cancel_timer(Timer* timer) {
  // Since the timer is part of a doubly linked list,
  // just delete it from the linked list and free the memory.
}</p>

<p>// Write the list of expired ids into the input array, assuming it is long enough.
void expire_timers(uint64_t* ids, uint64_t size) {
  // If it wasn&rsquo;t already clear this is pseudo code.
  deadline = calculate_deadline();
  int num_ids_added = 0;
  for (bucket : every bucket that could contain expired timers) {</p>

<pre><code>for (timer : bucket) {
  if (0 &gt;= timer-&gt;remainingRounds &amp;&amp; timer-&gt;deadline &lt;= deadline) {
    append_to_ids(ids, size, &amp;num_ids_added, timer-&gt;id);
    cancel_timer(timer);
  } else {
    --timer-&gt;remainingRounds;
  }
}
</code></pre>

<p>  }
}</p>

<figure class='code'><figcaption><span>Timer.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">So</span> <span class="n">our</span> <span class="n">algorithm</span> <span class="n">characteristics</span> <span class="n">in</span> <span class="n">brief</span> <span class="nl">are:</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="n">To</span> <span class="n">add</span> <span class="n">a</span> <span class="n">timer</span><span class="p">,</span> <span class="n">just</span> <span class="n">prepend</span> <span class="n">it</span> <span class="n">to</span> <span class="n">the</span> <span class="n">appropriate</span> <span class="n">linked</span> <span class="n">list</span> <span class="o">-</span> <span class="err">```</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">```</span>
</span><span class='line'><span class="mf">2.</span>  <span class="n">To</span> <span class="n">cancel</span> <span class="n">a</span> <span class="n">timer</span> <span class="o">-</span> <span class="k">delete</span> <span class="n">it</span> <span class="n">from</span> <span class="n">the</span> <span class="n">doubly</span> <span class="n">linked</span> <span class="n">list</span> <span class="o">-</span> <span class="err">```</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">```</span>
</span><span class='line'><span class="mf">3.</span>  <span class="n">To</span> <span class="n">clean</span> <span class="n">up</span> <span class="n">all</span> <span class="n">expired</span> <span class="n">timers</span> <span class="o">-</span> <span class="n">Travel</span> <span class="n">list</span> <span class="n">of</span> <span class="n">timers</span> <span class="n">and</span> <span class="k">delete</span> <span class="n">expired</span> <span class="n">ones</span> <span class="o">-</span> <span class="err">```</span><span class="n">O</span><span class="p">(</span><span class="n">expired</span> <span class="n">timers</span><span class="p">)</span><span class="err">```</span><span class="p">.</span> <span class="n">The</span> <span class="n">actual</span> <span class="n">time</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">how</span> <span class="n">many</span> <span class="n">timers</span> <span class="n">hashed</span> <span class="n">onto</span> <span class="n">a</span> <span class="n">bucket</span><span class="p">.</span> <span class="n">We</span> <span class="n">can</span> <span class="n">put</span> <span class="n">some</span> <span class="n">bounds</span> <span class="n">on</span> <span class="k">this</span> <span class="n">number</span> <span class="n">with</span> <span class="n">general</span> <span class="n">hash</span> <span class="n">table</span> <span class="n">math</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###### Comments on implementation.</span>
</span><span class='line'>
</span><span class='line'><span class="n">This</span> <span class="n">is</span> <span class="n">our</span> <span class="n">base</span> <span class="n">line</span><span class="p">.</span> <span class="n">We</span> <span class="n">have</span> <span class="n">significant</span> <span class="n">memory</span> <span class="n">over</span> <span class="n">head</span> <span class="n">in</span> <span class="n">terms</span> <span class="n">of</span> <span class="n">previous</span><span class="o">/</span><span class="n">next</span> <span class="n">pointers</span> <span class="n">on</span> <span class="n">our</span> <span class="n">timers</span><span class="p">.</span> <span class="n">It</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">pretty</span> <span class="n">terrible</span> <span class="n">that</span> <span class="n">we</span> <span class="n">have</span> <span class="n">to</span> <span class="err">```</span><span class="n">malloc</span><span class="p">()</span><span class="err">```</span> <span class="n">and</span> <span class="err">```</span><span class="n">free</span><span class="p">()</span><span class="err">```</span> <span class="n">on</span> <span class="n">each</span> <span class="err">```</span><span class="n">add_timer</span><span class="p">()</span><span class="err">```</span> <span class="n">and</span> <span class="err">```</span><span class="n">cancel_timer</span><span class="p">()</span><span class="err">```</span> <span class="n">call</span><span class="p">.</span> <span class="n">Of</span> <span class="n">course</span> <span class="n">the</span> <span class="err">```</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">```</span> <span class="n">calls</span> <span class="n">also</span> <span class="n">hide</span> <span class="n">the</span> <span class="n">fact</span> <span class="n">that</span> <span class="n">we</span> <span class="n">are</span> <span class="n">traversing</span> <span class="n">a</span> <span class="n">linked</span> <span class="n">list</span> <span class="n">during</span> <span class="n">timer</span> <span class="n">expiry</span> <span class="n">which</span> <span class="n">is</span> <span class="n">pretty</span> <span class="n">terrible</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#####2. Vector of timer pointers per bucket.</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span> <span class="n">align</span><span class="o">=</span><span class="s">&quot;center&quot;</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="s">&quot;/images/hashed-wheel-timer-vector.svg&quot;</span> <span class="n">width</span><span class="o">=</span><span class="s">&quot;500&quot;</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">Instead</span> <span class="n">of</span> <span class="n">an</span> <span class="n">intrusive</span> <span class="n">linked</span> <span class="n">list</span> <span class="n">we</span> <span class="n">can</span> <span class="n">just</span> <span class="n">store</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">timers</span><span class="p">.</span> <span class="n">We</span> <span class="n">can</span> <span class="n">grow</span> <span class="k">this</span> <span class="n">vector</span> <span class="n">as</span> <span class="n">needed</span><span class="p">.</span> <span class="n">If</span> <span class="n">memory</span> <span class="n">is</span> <span class="n">not</span> <span class="n">a</span> <span class="n">concern</span> <span class="n">we</span> <span class="n">could</span> <span class="n">allocate</span> <span class="n">a</span> <span class="n">large</span> <span class="n">enough</span> <span class="n">array</span> <span class="n">so</span> <span class="n">that</span> <span class="n">growing</span> <span class="n">is</span> <span class="n">never</span> <span class="n">needed</span> <span class="p">(</span><span class="n">though</span> <span class="n">still</span> <span class="n">accounted</span> <span class="k">for</span><span class="p">).</span> <span class="n">Our</span> <span class="n">timer</span> <span class="k">struct</span> <span class="n">now</span> <span class="n">looks</span> <span class="nl">like:</span>
</span></code></pre></td></tr></table></div></figure>


<p> cpp Timer.cpp</p>

<p>struct Timer {
  uint64_t id;
  uint64_t deadline;
  uint64_t remaining_rounds;
};</p>

<p>struct TimerBucket {
  int size;
  int capacity;
  // Array of pointers to timers.
  Timer* timers[];
};</p>

<figure class='code'><figcaption><span>Timer.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Our</span> <span class="n">algorithms</span> <span class="n">look</span> <span class="n">like</span>
</span></code></pre></td></tr></table></div></figure>


<p> cpp TimerWheel.cpp
Timer add_timer(uint64_t delay, uint64_t id) {
  Timer<em> timer = create_timer(delay, id);
  TimerBucket</em> bucket = findBucket(timer);
  // Just append the timer to the vector for the bucket.
  append_to_bucket(bucket, timer);
  return timer;
}</p>

<p>void cancel_timer(Timer* timer) {
  // Since the timer is part of a vector, we can&rsquo;t just adjust a couple pointers.
  // Since ordering within the vector is not important, we copy the last
  // timer pointer (if the deleted timer wasn&rsquo;t the last one in the vector)
  // to the deleted position.
  // Decrement the vector size by 1.
  // Moving the pointer to a timer within the vector doesn&rsquo;t invalidate the
  // pointer, so it&rsquo;s perfectly safe.
  // We then free the memory used by the timer.
}</p>

<p>// The expiry logic remains similar. We just traverse an array of pointers now
// instead of a doubly linked list.
void expire_timers(uint64_t* ids, uint64_t size) {
  // If it wasn&rsquo;t already clear this is pseudo code.
  deadline = calculate_deadline();
  int num_ids_added = 0;
  for (bucket : every bucket that could contain expired timers) {</p>

<pre><code>for (timer : bucket) {
  if (0 &gt;= timer-&gt;remainingRounds &amp;&amp; timer-&gt;deadline &lt;= deadline) {
    append_to_ids(ids, size, &amp;num_ids_added, timer-&gt;id);
    cancel_timer(timer);
  } else {
    --timer-&gt;remainingRounds;
  }
}
</code></pre>

<p>  }
}</p>

<figure class='code'><figcaption><span>Timer.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">So</span> <span class="n">our</span> <span class="n">algorithm</span> <span class="n">characteristics</span> <span class="n">in</span> <span class="n">brief</span> <span class="nl">are:</span>
</span><span class='line'>
</span><span class='line'><span class="mf">1.</span>  <span class="n">To</span> <span class="n">add</span> <span class="n">a</span> <span class="n">timer</span><span class="p">,</span> <span class="n">just</span> <span class="n">append</span> <span class="n">it</span> <span class="n">to</span> <span class="n">the</span> <span class="n">appropriate</span> <span class="n">vector</span> <span class="o">-</span> <span class="err">```</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">```</span><span class="p">.</span>
</span><span class='line'><span class="mf">2.</span>  <span class="n">To</span> <span class="n">cancel</span> <span class="n">a</span> <span class="n">timer</span><span class="p">,</span> <span class="k">delete</span> <span class="n">it</span> <span class="n">from</span> <span class="n">the</span> <span class="n">middle</span> <span class="n">of</span> <span class="n">the</span> <span class="n">vector</span> <span class="n">and</span> <span class="n">move</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">occupy</span> <span class="n">the</span> <span class="n">hole</span>  <span class="o">-</span> <span class="err">```</span><span class="n">O</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">```</span><span class="p">.</span>
</span><span class='line'><span class="mf">3.</span>  <span class="n">To</span> <span class="n">clean</span> <span class="n">up</span> <span class="n">all</span> <span class="n">expired</span> <span class="n">timers</span> <span class="o">-</span> <span class="n">Traverse</span> <span class="n">the</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">timers</span> <span class="n">and</span> <span class="k">delete</span> <span class="n">expired</span> <span class="n">ones</span> <span class="o">-</span> <span class="err">```</span><span class="n">O</span><span class="p">(</span><span class="n">expired</span> <span class="n">timers</span><span class="p">)</span><span class="err">```</span><span class="p">.</span> <span class="n">Again</span> <span class="n">actual</span> <span class="n">time</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">how</span> <span class="n">many</span> <span class="n">timers</span> <span class="n">hashed</span> <span class="n">onto</span> <span class="n">a</span> <span class="n">bucket</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="cp">###### Comments on implementation.</span>
</span><span class='line'>
</span><span class='line'><span class="n">This</span> <span class="n">is</span> <span class="n">a</span> <span class="n">slight</span> <span class="n">improvement</span> <span class="n">on</span> <span class="n">our</span> <span class="n">base</span> <span class="n">line</span><span class="p">.</span> <span class="n">By</span> <span class="k">using</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">timers</span> <span class="n">we</span> <span class="n">have</span> <span class="n">removed</span> <span class="n">the</span> <span class="n">need</span> <span class="k">for</span> <span class="n">the</span> <span class="n">next</span> <span class="n">pointers</span> <span class="o">-</span> <span class="n">a</span> <span class="n">slight</span> <span class="n">improvement</span> <span class="n">in</span> <span class="n">space</span> <span class="n">usage</span><span class="p">.</span> <span class="n">We</span> <span class="n">still</span> <span class="n">have</span> <span class="n">the</span> <span class="n">terrible</span> <span class="n">pattern</span> <span class="n">of</span> <span class="n">having</span> <span class="n">to</span>  <span class="n">use</span> <span class="err">```</span><span class="n">malloc</span><span class="p">()</span><span class="err">```</span> <span class="n">and</span> <span class="err">```</span><span class="n">free</span><span class="p">()</span><span class="err">```</span> <span class="n">on</span> <span class="n">each</span> <span class="err">```</span><span class="n">add_timer</span><span class="p">()</span><span class="err">```</span> <span class="n">and</span> <span class="err">```</span><span class="n">cancel_timer</span><span class="p">()</span><span class="err">```</span> <span class="n">call</span><span class="p">.</span> <span class="n">During</span> <span class="n">expiry</span> <span class="n">of</span> <span class="n">timers</span> <span class="n">we</span> <span class="n">now</span> <span class="n">traverse</span> <span class="n">a</span> <span class="n">vector</span> <span class="n">of</span> <span class="n">pointers</span> <span class="n">to</span> <span class="n">timers</span> <span class="n">instead</span> <span class="n">of</span> <span class="n">a</span> <span class="n">linked</span> <span class="n">list</span><span class="p">.</span> <span class="n">This</span> <span class="n">is</span> <span class="n">only</span> <span class="n">marginally</span> <span class="n">better</span> <span class="n">than</span> <span class="n">the</span> <span class="n">first</span> <span class="n">implementation</span> <span class="n">since</span> <span class="n">the</span> <span class="n">timers</span> <span class="n">themselves</span> <span class="n">are</span> <span class="n">allocated</span> <span class="n">randomly</span><span class="p">.</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#####3. Vector of inlined timers.</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span> <span class="n">align</span><span class="o">=</span><span class="s">&quot;center&quot;</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="s">&quot;/images/hashed-wheel-timer-inlined-vector.svg&quot;</span> <span class="n">width</span><span class="o">=</span><span class="s">&quot;500&quot;</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">Let</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">see</span> <span class="k">if</span> <span class="n">we</span> <span class="n">can</span> <span class="n">improve</span> <span class="n">effiency</span> <span class="n">by</span> <span class="n">making</span> <span class="n">our</span> <span class="n">interface</span> <span class="n">even</span> <span class="n">more</span> <span class="n">specialized</span><span class="p">.</span> <span class="n">So</span> <span class="n">far</span> <span class="n">we</span> <span class="n">have</span> <span class="n">returned</span> <span class="n">a</span> <span class="err">```</span><span class="n">Timer</span><span class="o">*</span><span class="err">```</span> <span class="n">on</span> <span class="n">an</span> <span class="err">```</span><span class="n">add_timer</span><span class="p">()</span><span class="err">```</span> <span class="n">call</span><span class="p">.</span> <span class="n">Our</span> <span class="n">intented</span> <span class="n">use</span> <span class="k">for</span> <span class="n">the</span> <span class="err">```</span><span class="n">Timer</span><span class="o">*</span><span class="err">```</span> <span class="n">is</span> <span class="n">to</span> <span class="n">cancel</span> <span class="n">the</span> <span class="n">timer</span> <span class="k">using</span> <span class="k">this</span> <span class="n">pointer</span><span class="p">.</span> <span class="n">Thus</span> <span class="n">we</span> <span class="n">will</span> <span class="n">end</span> <span class="n">up</span> <span class="n">stashing</span> <span class="k">this</span> <span class="n">pointer</span> <span class="n">somewhere</span><span class="p">.</span> <span class="n">Maybe</span> <span class="n">on</span> <span class="n">a</span> <span class="n">per</span> <span class="n">connection</span> <span class="n">structure</span> <span class="n">or</span> <span class="n">a</span> <span class="n">hash</span> <span class="n">map</span> <span class="n">or</span> <span class="n">something</span><span class="p">.</span> <span class="n">What</span> <span class="k">if</span> <span class="n">we</span> <span class="n">could</span> <span class="n">store</span> <span class="n">a</span> <span class="n">pointer</span> <span class="n">to</span> <span class="k">this</span> <span class="n">timer</span> <span class="n">holder</span> <span class="n">structure</span> <span class="p">(</span><span class="n">that</span> <span class="n">points</span> <span class="n">to</span> <span class="n">our</span> <span class="n">timer</span><span class="p">)</span> <span class="n">in</span> <span class="n">our</span> <span class="n">timer</span><span class="o">?</span> <span class="n">We</span> <span class="n">could</span> <span class="n">then</span> <span class="n">safely</span> <span class="n">move</span><span class="o">/</span><span class="n">invalidate</span> <span class="n">the</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">a</span> <span class="n">timer</span><span class="p">,</span> <span class="n">updating</span> <span class="n">the</span> <span class="n">only</span> <span class="n">place</span> <span class="n">where</span> <span class="k">this</span> <span class="n">timer</span> <span class="n">was</span> <span class="n">actually</span> <span class="n">referenced</span><span class="p">.</span> <span class="n">Here</span> <span class="n">we</span> <span class="n">assume</span> <span class="n">that</span> <span class="n">the</span> <span class="n">pointer</span> <span class="n">to</span> <span class="n">the</span> <span class="n">timer</span> <span class="n">was</span> <span class="n">stashed</span> <span class="n">in</span> <span class="n">only</span> <span class="n">one</span> <span class="n">place</span><span class="p">.</span> <span class="n">This</span> <span class="n">is</span> <span class="n">somewhat</span> <span class="n">like</span> <span class="n">our</span> <span class="n">own</span> <span class="n">little</span> <span class="n">garbage</span> <span class="n">collector</span> <span class="n">updating</span> <span class="n">references</span> <span class="n">to</span> <span class="n">timer</span> <span class="n">objects</span> <span class="n">that</span> <span class="n">were</span> <span class="n">moved</span> <span class="n">around</span><span class="p">.</span> <span class="n">Let</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">look</span> <span class="n">at</span> <span class="n">our</span> <span class="k">new</span> <span class="n">data</span> <span class="nl">structures:</span>
</span></code></pre></td></tr></table></div></figure>


<p> cpp NewTimer.h</p>

<p>// Holder of a pseudo-pointer to a timer.
// This can be used to cancel the timer.
struct TimerHolder {
  uint32_t bucket_number;
  uint32_t index_within_bucket;
};</p>

<p>struct Timer {
  uint64_t id;
  uint64_t deadline;
  uint64_t remaining_rounds;
  // Pointer to the sole container of this timer.
  TimerHolder* holder;
};</p>

<p>struct TimerBucket {
  int size;
  int capacity;
  // Array of Timers.
  Timer* timers;
};</p>

<figure class='code'><figcaption><span>Timer.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Our</span> <span class="n">modified</span> <span class="n">interface</span> <span class="n">now</span> <span class="nl">is:</span>
</span></code></pre></td></tr></table></div></figure>


<p> cpp TimerWheel.h
// Put the pointer to the timer in the holder.
void add_timer(uint64_t delay, uint64_t id, TimerHolder* holder);</p>

<p>// The TimerHolder is always kept up to date. Since this is a single threaded timer
// this is not impossible to ensure.
void cancel_timer(TimerHolder* timer);</p>

<p>// Write the list of expired ids into the input array, assuming it is long enough.
void expire_timers(uint64_t* ids, uint64_t size);</p>

<figure class='code'><figcaption><span>Timer.cpp</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='cpp'><span class='line'><span class="n">Our</span> <span class="n">algorithms</span> <span class="n">look</span> <span class="n">like</span>
</span></code></pre></td></tr></table></div></figure>


<p> cpp TimerWheel.cpp
void add_timer(uint64_t delay, uint64_t id, TimerHolder<em> holder) {
  TimerBucket</em> bucket = findBucket(timer);
  // Just append timer to end of the bucket, no malloc needed.
  // Update the holder to contain the bucket_number and index_within_bucket.
  initalize_timer(bucket, delay, id, holder);
}</p>

<p>void cancel_timer(TimerHolder<em> holder) {
  // Do some sanity checking first.
  TimerBucket</em> bucket = find_bucket(holder->bucket_number);
  uint32_t cancelled_timer_index = holder->index_within_bucket;
  Timer<em> timer = find_timer(bucket, cancelled_timer_index);
  // We need to cancel this timer.
  // Just memcpy the last timer in this bucket to occupy the deleted place.
  // A timer is just 32 bytes, copying it VS copying a pointer is not a big deal.
  // If the cancelled timer is the last timer in this bucket no copy is needed.
  // Decrement the vector size by 1.
  Timer</em> moved_timer = move_last_timer_if_needed(bucket, cancelled_timer_index);
  if (moved_timer != nullptr) {</p>

<pre><code>// If a timer that was moved, change it's holder's offsets, 
// so it points to the new location of the timer.
adjust_holder_pointer(moved_timer-&gt;holder, cancelled_timer_index);
</code></pre>

<p>  }
  // The holder for the deleted timer should now contain a null ptr.
  // The caller will decide what to do with the holder after this function returns.
  invalidate_holder_timer(holder);
}</p>

<p>// The expiry logic remains similar. We just traverse an array of inlined timers now.</p>

<p>void expire_timers(uint64_t* ids, uint64_t size) {
  // If it wasn&rsquo;t already clear this is pseudo code.
  deadline = calculate_deadline();
  int num_ids_added = 0;
  for (bucket : every bucket that could contain expired timers) {</p>

<pre><code>for (timer : bucket) {
  if (0 &gt;= timer-&gt;remainingRounds &amp;&amp; timer-&gt;deadline &lt;= deadline) {
    append_to_ids(ids, size, &amp;num_ids_added, timer-&gt;id);
    cancel_timer(timer-&gt;holder);
  } else {
    --timer-&gt;remainingRounds;
  }
}
</code></pre>

<p>  }
}
&#8220;`
So our algorithm characteristics in brief are:</p>

<ol>
<li>To add a timer, just scribble some data to the end of the appropriate vector &ndash; <code>O(1)</code>.</li>
<li>To cancel a timer, copy the last timer in the bucket to the position of the deleted one and adjust references to the moved timer &ndash; <code>O(1)</code>.</li>
<li>To clean up all expired timers &ndash; Traverse the vector of timers and delete expired ones using the <code>cancel_timer()</code> call &ndash; <code>O(expired timers)</code>. Again actual time depends on how many timers hashed onto a bucket.</li>
</ol>


<h6>Comments on implementation.</h6>

<p>We no longer call <code>malloc()</code> and <code>free()</code> on every timer call. Instead we manage large buckets and copy small amounts of data around to manage deletions. We ended up storing a pointer to the holder of the timer object but overall we are not storing any more data that the other implementations. When we got rid of the <code>malloc()</code> and <code>free()</code> calls we also got rid of any fragmentation arising from them. Further during expiry processing we iterate through a chunk of contiguous memory instead of pointer chasing.</p>

<h3>Conclusion</h3>

<p>By analyzing the context of our timer algorithm we were able to come up with a better implementation albeit a more tightly coupled one. Wholistic analysis of a particular piece of software often opens up such opportunities for efficiency gains. Though many a time there is a <code>efficiency</code> VS <code>other-non-tangibles</code> trade-off, I&rsquo;ve been surprised by the number of times such gains have been made without tigher coupling.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Rajiv</span></span>

      








  


<time datetime="2014-11-11T20:22:55-08:00" pubdate data-updated="true">Nov 11<span>th</span>, 2014</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/datastructures/'>DataStructures</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://RajivKurian.github.io/blog/2014/11/11/hashed-wheel-timer-an-exercise-in-data-structures/" data-via="" data-counturl="http://RajivKurian.github.io/blog/2014/11/11/hashed-wheel-timer-an-exercise-in-data-structures/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/11/11/reading-length-prefixed-protocols/" title="Previous Post: Reading length prefixed protocols">&laquo; Reading length prefixed protocols</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/11/11/hashed-wheel-timer-an-exercise-in-data-structures/">Hashed Wheel Timer - an Exercise in Data Structures</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/11/reading-length-prefixed-protocols/">Reading Length Prefixed Protocols</a>
      </li>
    
  </ul>
</section>




<section>
  <h1>About Me</h1>
  <p>I can't think of anything remotely interesting.</p>
</section>
  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Rajiv -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'rajivkuriangithub';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://RajivKurian.github.io/blog/2014/11/11/hashed-wheel-timer-an-exercise-in-data-structures/';
        var disqus_url = 'http://RajivKurian.github.io/blog/2014/11/11/hashed-wheel-timer-an-exercise-in-data-structures/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
